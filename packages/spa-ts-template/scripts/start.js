// Do this as the first thing so that any code reading it knows the right env.
process.env.BABEL_ENV = 'development';
process.env.NODE_ENV = 'development';

// Makes the script crash on unhandled rejections instead of silently
// ignoring them. In the future, promise rejections that are not handled will
// terminate the Node.js process with a non-zero exit code.
process.on('unhandledRejection', err => {
    if (err) {
        throw err;
    }
});

// Ensure environment variables are read.
require('./config/env');

const chalk = require('react-dev-utils/chalk');
const webpack = require('webpack');
const ora = require('nut-up-utils/ora');
const WebpackDevServer = require('webpack-dev-server');
const clearConsole = require('react-dev-utils/clearConsole');
const checkRequiredFiles = require('react-dev-utils/checkRequiredFiles');
const openBrowser = require('react-dev-utils/openBrowser');
const { checkBrowsers } = require('react-dev-utils/browsersHelper');
const { choosePort, createCompiler, prepareProxy, prepareUrls } = require('nut-up-utils/WebpackDevServerUtils');
const checkMissDependencies = require('nut-up-utils/checkMissDependencies');
const { createDevServerConfig } = require('./config/helper');
const paths = require('./config/paths');
const configFactory = require('./config/webpack.config');
const { ensureLocals } = require('./i18n');
const pkg = paths.appPackageJson;

const isInteractive = process.stdout.isTTY;

// Warn and crash if required files are missing
if (!checkRequiredFiles([paths.appHtml, paths.appIndexJs])) {
    console.log();
    process.exit(1);
}

// Ensure 'locals' dir exist
ensureLocals();

const spinner = ora('webpack启动中...').start();
// Tools like Cloud9 rely on this.
const DEFAULT_PORT = parseInt(process.env.PORT, 10) || 3000;
const HOST = process.env.HOST || '0.0.0.0';

checkMissDependencies(paths.root, paths.npmCommander, spinner).then(() => {
    // We require that you explicitly set browsers and do not fall back to
    // browserslist defaults.
    return checkBrowsers(paths.root, isInteractive)
        .then(() => {
            // We attempt to use the default port but if it is busy, we offer the user to
            // run on a different port. `choosePort()` Promise resolves to the next free port.
            return choosePort(HOST, DEFAULT_PORT, spinner);
        })
        .then(port => {
            if (port == null) {
                console.log();

                spinner.fail(
                    `请关闭占用 ${chalk.bold(
                        chalk.yellow(DEFAULT_PORT)
                    )} 端口的程序后再运行；或者指定一个新的端口：${chalk.bold(chalk.yellow('PORT=4000 npm start'))}`
                );

                console.log();
                process.exit(0);
            }

            const config = configFactory('development');
            const protocol = process.env.HTTPS === 'true' ? 'https' : 'http';
            const appName = pkg.name;
            const tscCompileOnError = process.env.TSC_COMPILE_ON_ERROR === 'true';
            const urls = prepareUrls(protocol, HOST, port, paths.publicUrlOrPath.slice(0, -1));
            const devSocket = {
                warnings: warnings => devServer.sendMessage(devServer.webSocketServer.clients, 'warnings', warnings),
                errors: errors => {
                    devServer.sendMessage(devServer.webSocketServer.clients, 'errors', errors);
                }
            };
            // Create a webpack compiler that is configured with custom messages.
            const compiler = createCompiler({
                appName,
                config: [config],
                devSocket,
                urls,
                tscCompileOnError,
                webpack,
                spinner
            });
            const proxySetting = process.env.PROXY || pkg.proxy;
            const proxyConfig = prepareProxy(proxySetting, paths.appPublic, paths.publicUrlOrPath);
            // Serve webpack assets generated by the compiler over a web server.
            const serverConfig = createDevServerConfig(proxyConfig, urls.lanUrlForConfig, HOST, port);
            const devServer = new WebpackDevServer(serverConfig, compiler);
            // Launch WebpackDevServer.
            devServer.startCallback(() => {
                if (isInteractive) {
                    clearConsole();
                }

                spinner.text = chalk.cyan('正在启动测试服务器...');
                openBrowser(urls.localUrlForBrowser);
            });

            ['SIGINT', 'SIGTERM'].forEach(function (sig) {
                process.on(sig, function () {
                    spinner.stop();
                    devServer.close();
                    process.exit();
                });
            });

            if (isInteractive || process.env.CI !== 'true') {
                // Gracefully exit when stdin ends
                process.stdin.on('end', function () {
                    devServer.close();
                    process.exit();
                });
                // todo study
                process.stdin.resume();
            }
        })
        .catch(err => {
            if (err) {
                console.log(err.message || err);
                console.log();
            }

            spinner.stop();

            process.kill(process.pid, 'SIGINT');
        });
});
